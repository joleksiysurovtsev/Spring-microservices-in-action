# Spring Cloud #

Фреймворк Spring Cloud предлагает ряд функций (регистрации и обнаружения служб, размыкания цепи, мониторинга и др.),
позволяющих быстро создавать микросервисные архитектуры с минимальны ми конфигурациями.

Spring Cloud – это коллекция инструментов, объединяющая разработки с открытым исходным кодом многих компаний, таких как
VMware, HashiCorp и Netflix. Spring Cloud упрощает установку и настройку наших проектов и предоставляет реализации
шаблонов, особенно часто встречающихся в приложениях на основе Spring.

На рис показаны шаблоны, и их деление на проекты в Spring Cloud.

![chapter2_img1_spring_cloud_patterns.png](img/chapter2/chapter2_img1_spring_cloud_patterns.png)

## Spring Cloud Config ##

Spring Cloud Config помогает организовать управление конфигурационными данными приложения через централизованную службу,
что позволяет четко отделить конфигурацию приложения (в частности, настройки окружения) от развернутого микросервиса.
Благодаря такому подходу все экземпляры микросервиса, независимо от их количества, будут иметь одинаковую конфигурацию.

Cloud Config имеет свой репозиторий управления свойствами, а также интегрируется со многими проектами с открытым
исходным кодом, такими как:

- Git (https://git-scm.com/). Система управления версиями с открытым исходным кодом, которая позволяет контролировать
  изменения в любых текстовых файлах. Spring Cloud Config может интегрироваться с репозиторием Git и извлекать из него
  конфигурации приложений;

- Consul (https://www.consul.io/). Система обнаружения служб с открытым исходным кодом, которая позволяет регистрировать
  в ней экземпляры служб. Клиенты могут обращаться к системе Consul, чтобы узнать местоположение экземпляров нужных им
  служб. Также Consul имеет свое хранилище пар ключ/значение, в котором Spring Cloud Config может хранить конфигурации
  приложений;

- Eureka (https://github.com/Netflix/eureka). Проект Netflix с открытым исходным кодом, который, как и Consul,
  предлагает аналогичные возможности обнаружения служб. В Eureka тоже есть свое хранилище пар ключ/значение, которое
  может использоваться Spring Cloud Config.

## Spring Cloud Service Discovery ##

Шаблон Spring Cloud Service Discovery помогает организовать обнаружение служб клиентами независимо от физического
местоположения (IP-адреса и/или имени) ваших серверов. Клиенты вызывают бизнес-логику, используя логическое имя вместо
физического адреса. Spring Cloud Service Discovery также предусматривает регистрацию экземпляров службы при их запуске и
отмену регистрации по завершении работы. Реализовать Spring Cloud Service Discovery можно с помощью:

Consul (https://www.consul.io/); Zookeeper (https://spring.io/projects/spring-cloud-zookeeper);
Eureka (https://github.com/Netflix/eureka) в качестве механизма обнаружения служб.

## Spring Cloud LoadBalancer и Resilience4j ##

Библиотеку Resilience4j можно найти по адресу: https://github.com/resilience4j/resilience4j. С помощью библиотеки
Resilience4j можно быстро реализовать такие шаблоны отказоустойчивости клиента, как размыкатель цепи (Circuit Breaker),
повторные попытки
(Retries), герметичные отсеки (Bulkhead) и др.

## Spring Cloud API Gateway ## 

API Gateway предоставляет возможность маршрутизации служб в приложениях на основе микросервисов. Как следует из названия
(API Gateway – API-шлюз), это – шлюз, передающий запросы службам и служащий единой точкой входа в ваши микросервисы.
Такая централизация позволяет применять стандартные политики, такие как авторизация, аутентификация, фильтрация
содержимого и правила маршрутизации. API-шлюз можно реализовать с помощью Spring Cloud
Gateway (https://spring.io/projects/spring-cloudgateway).

## Spring Cloud Stream ## 

Spring Cloud Stream (https://cloud.spring.io/spring-cloud-stream) – это технология, позволяющая интегрировать
легковесную обработку сообщений в микросервисы. С помощью Spring Cloud Stream можно создавать интеллектуальные
микросервисы, использующие асинхронные события, которые происходят в вашем приложении. Также Spring Cloud Stream
позволяет быстро интегрировать микросервисы с брокерами сообщений, такими как RabbitMQ (https://www.rabbitmq.com) и
Kafka (http://kafka.apache.org).

## Spring Cloud Sleuth ## 

Spring Cloud Sleuth (https://cloud.spring.io/spring-cloud-sleuth/) позволяет интегрировать уникальные идентификаторы
трассировки в HTTP-вызовы и каналы сообщений (RabbitMQ, Apache Kafka), используемые в приложении. Идентификаторы
трассировки, которые иногда называют идентификаторами корреляции, помогают отслеживать прохождение транзакций через
различные службы. Spring Cloud Sleuth автоматически добавляет идентификаторы трассировки в любые операции
журналирования, выполняемые в микросервисе. Достоинства Spring Cloud Sleuth особенно ярко проявляются в сочетании с
инструментами агрегирования журналов, такими как ELK Stack (https://www.elastic.co/what-is/elk-stack), и трассировки,
такими как Zipkin (http://zipkin.io). Open Zipkin принимает данные, созданные Spring Cloud Sleuth, и визуализирует поток
вызовов служб, задействованных в данной транзакции. ELK Stack – это аббревиатура, составленная из первых букв названий
трех проектов с открытым исходным кодом:

- Elasticsearch (https://www.elastic.co) – поисковая и аналитическая система;

- Logstash (https://www.elastic.co/products/logstash) – конвейер обработки данных на стороне сервера, который принимает
  данные и преобразует их для отправки в «хранилище» (stash);

- Kibana (https://www.elastic.co/products/kibana) – клиентский интерфейс, с помощью которого пользователи могут
  запрашивать и визуализировать данные всего стека.

## Spring Cloud Security ## 

Spring Cloud Security (https://cloud.spring.io/spring-cloudsecurity/)
– это фреймворк аутентификации и авторизации, управляющий доступом к вашим службам и операциям. Принцип действия Spring
Cloud Security основан на токенах, что позволяет службам взаимодействовать друг с другом, используя токены, выданные
сервером аутентификации. Каждая служба, получив HTTP-запрос, может проверить предоставленный токен, чтобы подтвердить
личность пользователя и его привилегии. Spring Cloud Security также поддерживает веб-токены JSON Web Tokens
(JWT). JWT (https://jwt.io) определяет стандартный формат для создания токена OAuth2 и нормализует цифровые подписи для
сгенерированного токена.

## **Приемы создания облачных микросервисов** ## 

Приложение, **_пригодное для использования в облаке_**, – это приложение, которое первоначально предназначалось для
выполнения на локальном компьютере или сервере. Чтобы сделать такое приложение пригодным для использования в облаке,
нужно вынести его конфигурацию вовне, чтобы адаптировать ее к различным окружениям. В этом случае мы сможем обеспечить
работу приложения в нескольких окружениях без изменения исходного кода.

_**Изначально облачное приложение**_ с самого начала проектировалось для работы в облачном окружении и способно
использовать все его преимущества. При создании приложений этого типа разработчики разбивают функции на микросервисы и
организуют их в масштабируемые компоненты, такие как контейнеры, что позволяет им выполняться на нескольких серверах.
Эти службы управляются виртуальными инфраструктурами через процессы DevOps и непрерывной доставки. Важно понимать, что
приложения, пригодные для использования в облаке, не требуют никаких изменений или преобразований. Они уже
предусматривают обработку ситуаций, когда нижестоящие компоненты могут оказаться недоступными.

### Четыре принципа разработки изначально облачных приложений ###

1. DevOps – это аббревиатура из начальных букв слов «development»
   (Dev; разработка) и «operations» (Ops; эксплуатация). Она обозначает методологию разработки программного обеспечения,
   предполагающую тесное сотрудничество разработчиков и специалистов, осуществляющих эксплуатацию и сопровождение
   программного обеспечения. Основная цель этой методологии – автоматизировать процессы доставки программного
   обеспечения и минимизировать затраты на изменение инфраструктуры;

2. микросервисы – это небольшие, слабо связанные распределенные службы. Архитектура микросервисов позволяет взять
   большое приложение и разложить его на простые в управлении компоненты с узко ограниченными обязанностями, а также
   помогает бороться с проблемами сложности, характерными для больших баз кода, разбивая их на мелкие, четко
   определенные части;
   
3. непрерывная доставка – это практика разработки программного обеспечения. Согласно этой практике процесс доставки 
   программного обеспечения автоматизируется, что обеспечивает быструю доставку в промышленное окружение;
   
4. контейнеры являются естественным продолжением развертывания микросервисов в образе виртуальной машины (ВМ). Вместо
   полноценной ВМ многие разработчики развертывают свои службы в контейнерах Docker (или в аналогичных системах
   управления контейнерами) в облаке.


Для решения проблем, сопутствующих созданию облачных микросервисов, можно использовать руководство с названием
_**«Приложение двенадцати факторов»**_ Методология двенадцати факторов может быть применена для приложений, 
написанных на любом языке программирования и использующих любые комбинации сторонних служб (backing services) 
(базы данных, очереди сообщений, кэш-памяти, и т.д.).

📙 Методология двенадцати факторов, представляет наиболее полный свод правил, которым нужно следовать при создании 
облачных приложений.

![TwelveFactors.png](img/TwelveFactors.png)

## [I. Кодовая база](additional/TwelveFactors/I.md) ##
Одна кодовая база, отслеживаемая в системе контроля версий, – множество развёртываний


## [II. Зависимости](additional/TwelveFactors/II.md) ##
Явно объявляйте и изолируйте зависимости

## [III. Конфигурация](additional/TwelveFactors/III.md) ##
Сохраняйте конфигурацию в среде выполнения

## [IV. Сторонние службы](additional/TwelveFactors/IV.md) ##
IV. Сторонние службы (Backing Services)
Считайте сторонние службы (backing services) подключаемыми ресурсами

V. Сборка, релиз, выполнение
Строго разделяйте стадии сборки и выполнения

VI. Процессы
Запускайте приложение как один или несколько процессов не сохраняющих внутреннее состояние (stateless)

VII. Привязка портов (Port binding)
Экспортируйте сервисы через привязку портов

VIII. Параллелизм
Масштабируйте приложение с помощью процессов

IX. Утилизируемость (Disposability)
Максимизируйте надёжность с помощью быстрого запуска и корректного завершения работы

X. Паритет разработки/работы приложения
Держите окружения разработки, промежуточного развёртывания (staging) и рабочего развёртывания (production) максимально похожими

XI. Журналирование (Logs)
Рассматривайте журнал как поток событий

XII. Задачи администрирования
Выполняйте задачи администрирования/управления с помощью разовых процессов